## GitHub Copilot로 레거시 프로젝트 업그레이드하기<h1 align="center">GitHub Copilot으로 Python 프로젝트 업그레이드하기</h1>

<h5 align="center">레거시 코드에서 최신 안정 버전으로 복잡한 업그레이드 수행</h3>

이 워크숍에서는 GitHub Copilot의 도움을 받아 레거시(구버전) Python 애플리케이션을 최신 Python 버전으로 업그레이드하는 과정을 안내합니다.

<p align="center">

> [!NOTE]  <a href="#mega-prerequisites">사전 준비 사항</a> •

> 이 저장소는 **GitHub Copilot**의 다양한 기능(**Copilot Chat**, **인라인 채팅**)을 소개하기 위한 것입니다. 아래 단계별 가이드에는 필요한 작업의 일반적인 설명이 포함되어 있으며, Copilot Chat 또는 인라인 채팅을 통해 필요한 명령을 생성할 수 있습니다.  <a href="#books-resources">참고 자료</a> •

>  <a href="#learning-objectives">학습 목표</a>

> 각 단계(해당되는 경우)에는 Copilot 제안을 검증할 수 있는 `Cheatsheet`도 포함되어 있습니다.</p>

>

> 💡 다양한 프롬프트를 시도해보고 Copilot 제안의 정확도가 어떻게 달라지는지 확인하세요. 인라인 채팅을 사용할 때는 추가 프롬프트로 응답을 세밀하게 조정할 수 있습니다.- **대상**: GitHub Copilot을 활용한 AI 페어 프로그래밍 기법으로 레거시 코드의 어려운 업그레이드 시나리오를 수행하고자 하는 모든 기술자

- **학습 내용**: 프로젝트 업그레이드에 특히 유용한 GitHub Copilot의 고급 활용법을 익힙니다. 이 기법과 패턴은 프로젝트 업그레이드뿐 아니라 신규 개발에도 적용할 수 있습니다.

## 워크숍 특징- **결과물**: Python 2.5의 레거시 및 폐기된 구문을 최신 Python 3 버전으로 전환한 완전히 개편된 Python 프로젝트



이 워크숍에서는 Python 2.5 버전을 사용하던 레거시 애플리케이션을 다룹니다. 주요 특징은 다음과 같습니다:> [!NOTE]

> 워크숍을 찾고 계신가요? [워크숍 디렉터리](./workshop)로 이동하세요.

1. 모든 의존성은 미리 설치되어 있지만, 레거시 애플리케이션은 구버전 Python을 사용합니다.

2. Sqlite3 및 구식 Python 문법을 사용하며, 이를 최신 문법으로 업데이트할 수 있습니다.## 학습 목표

3. 레거시 애플리케이션에는 기능 테스트에 활용할 수 있는 문서가 포함되어 있습니다.

4. 유닛 테스트와 기능 테스트가 레거시 코드에 포함되어 있습니다.이 워크숍에서는 다음을 수행합니다:



### 1. 에이전트로 프로젝트 탐색  - 레거시 프로젝트를 다루기 위한 GitHub Copilot 고급 상호작용 기법 활용

  - 레거시 프로젝트를 업그레이드하고 정확성을 검증하기 위한 반복, 검증, 개선

`@workspace` 에이전트를 사용해 프로젝트의 구조와 동작을 설명받으세요.  - 더 나은 결과를 얻기 위한 다양한 전략과 제안 개선을 위한 일반적 개념 적용

- GitHub Copilot Chat을 열고 프롬프트 앞에 `@workspace`를 붙여 질문하세요.  - 업그레이드 후 프로젝트의 최종 상태를 검증할 수 있는 철저한 테스트 전략 구축

- 예) "이 프로젝트는 의존성을 어떻게 설치하나요?"

## :mega: 사전 준비 사항

### 2. 레거시 문제와 포팅 이슈 파악

워크숍 참여 전 준비물은 단 하나입니다: 공개 GitHub 계정. 모든 자료, 의존성, 데이터는 저장소에 포함되어 있습니다. GitHub Copilot 라이선스, 체험판 또는 무료 버전을 준비하세요.

Python 애플리케이션의 테스트를 실행해보고, `pytest`를 사용해 결과를 확인하세요.

- "@workspace 이 코드를 최신 Python으로 포팅할 때 발생할 수 있는 문제는?" 등 질문## 주요 요점

- 가상환경에서 의존성 설치 시도

### 1. 명확한 목표와 요구사항 정의

> [!NOTE]

> 왜 작동하지 않을 수 있나요? 레거시 Python에서 더 이상 지원되지 않는 `distribute`를 사용하므로 의존성 설치가 실패할 수 있습니다. Copilot에게 다른 설치 방법을 제안받으세요.*무엇을 달성해야 하는가?*



### 3. 코드를 upgraded 디렉터리로 복사최종 목표를 명확히 이해하는 것부터 시작하세요. 레거시 프로젝트 업그레이드의 경우, 중요한 변경 시 정확성과 완성을 검증할 수 있는 철저한 테스트 전략이 필요합니다.



코드를 포팅하려면 모든 코드를 `upgraded` 디렉터리로 복사해야 합니다. 여기서 작업을 진행합니다.*제약 조건은 무엇인가?*

- 기능 테스트를 활용해 집중할 기능 단위를 정하세요.

제한 사항이나 제외 항목을 파악하세요. 예를 들어, 대형 언어 모델(LLM)은 충분한 맥락을 제공하지 못할 수 있습니다. 목표 달성을 위해서는 직접 결정을 내려야 합니다. 운영 환경에서 사용하는 프로젝트라면 새로운 라이브러리나 기능 추가가 기존 코드를 깨뜨릴 수 있으므로 제한될 수 있습니다.

> [!NOTE]

> 비즈니스 로직에 따라 LLM이 명확히 알지 못하는 컴포넌트가 있을 수 있습니다.> [!TIP]

> 문제의 범위를 정확히 설정하세요. 확신이 없다면 넓게 시작해 점차 세부적으로 좁혀가세요.

### 4. 프로젝트 설치

### 2. 문제를 구성 요소로 분해

가상환경을 만들고 프로젝트를 설치하세요. `python setup.py develop` 명령을 실행해 오류를 확인합니다.

- Copilot Chat에 오류를 붙여넣고 원인과 해결책을 질문하세요.문제를 더 작고 관리 가능한 단위로 분해하세요. 예를 들어, 핵심 애플리케이션 구성 요소부터 시작해 단일 API 엔드포인트나 라이브러리 함수 테스트로 확장합니다. 단계별로 문제를 이해하고 해결하기 쉬워집니다:

- `#file:setup.py`로 파일을 맥락에 추가하세요.

- Copilot의 제안대로 오류를 수정하고 설치를 완료하세요.- 공개 함수, API 엔드포인트

- 테스트, 테스트 설정 및 검증 스크립트

### 5. 테스트 실행- 구성 및 설치 과정



`pytest` 프레임워크와 CLI가 설치되어 있습니다. 유닛 테스트를 실행하고 오류를 확인하세요.각 조건을 단계별로 적용하세요. 복잡한 함수를 작은 헬퍼 함수로 나누면 작성과 디버깅이 쉬워집니다.

- 오류 출력을 Copilot에 질문할 때 `#terminalSelection`을 활용하세요.

- Copilot의 답변을 검토하고 추가 질문하세요.> [!TIP]

- 아직 코드를 수정하지 마세요.> 분해는 복잡성을 다루는 훌륭한 방법입니다. 한 번에 하나의 작은 작업에 집중할 수 있습니다.



> [!NOTE]### 3. 작업 단위(Slice) 생성

> 오류가 바로 이해되지 않거나 Python 버전 문제를 나타낼 수 있습니다. 추가 질문을 통해 오류의 원인을 파악하고 전략을 세우세요. 프로젝트가 구버전 Python을 사용했다는 점을 힌트로 주세요.

작업 단위는 전체 문제의 작고 관리 가능한 부분입니다. 구성 요소로 분해하는 것과 유사하지만, 완료해야 할 구체적인 작업에 집중합니다. 특정 기능이나 동작을 검증하는 기능 테스트와 유사합니다. 예를 들어, 레거시 프로젝트 업그레이드 시 단일 라이브러리나 함수 업그레이드에 집중할 수 있습니다.

### 6. try/except 오류 수정이렇게 하면 한 번에 하나의 작은 작업에 집중할 수 있고, 변경 사항을 테스트하고 검증하기 쉬워집니다.



기능 테스트를 활용해 집중할 기능 단위를 정하고, try/except 오류를 수정하세요.> [!TIP]

- Copilot에게 구버전 Python 문제임을 언급하며 실제 오류 해결을 요청하세요.> 작업 단위를 만들 때 기능 테스트를 고려하세요. 변경 사항을 쉽게 검증할 수 있도록 테스트 스크립트나 전체 테스트 스위트를 만드세요.

- 모든 try/except 오류를 수정하고 테스트를 반복 실행하세요.

### 4. 반복 및 솔루션 개선

> [!NOTE]

> 예외 처리 외에도 다른 오류가 있을 수 있습니다. 모든 try/except를 먼저 수정하세요.간단하게 시작해 점차 개선하세요. 복잡한 문제는 처음 시도가 완벽하지 않은 경우가 많습니다. 기본 솔루션을 생성한 후 점진적으로 발전시키세요.



### 7. ConfigParser 문제 해결> [!TIP]

> 반복할 때마다 예상 결과에 대해 테스트하고 검증하여 올바른 방향으로 가고 있는지 확인하세요.

다음 단계는 `ConfigParser`가 없다는 문제입니다. Copilot에게 해결 전략을 요청하세요.

- "이 프로젝트는 Python 2.5로 작성되었고, Python 3.9에서 다음 오류가 발생합니다:" 등으로 질문### 5. 예시를 활용해 요구사항 명확화

- 간단한 해결책을 선택해 바로 적용하세요.

- 테스트를 실행해 변경 사항을 검증하세요.AI 모델 프롬프트나 문제 설명 시 예시를 제공하세요. 예시는 기대하는 바를 명확히 전달해 문제 해결에 참여하는 사람이나 도구(GitHub Copilot 등) 모두에게 도움이 됩니다.



> [!NOTE]예를 들어, 레거시 코드의 경우 입력과 기대 출력, 그리고 작업을 수행하는 논리를 함께 설명할 수 있습니다.

> 모든 테스트가 통과해야 합니다. 실패 시 Copilot에 출력 결과를 질문해 이전 단계들을 재검토하세요.

> [!TIP]

### 8. 테스트를 Pytest로 포팅> 예시 기반 문제 해결은 이해를 맞추는 데 효과적입니다. 모호한 작업에 특히 유용합니다.



레거시 코드는 `unittest`를 사용합니다. 더 강력한 `pytest`로 모든 테스트를 포팅하세요.### 6. 패턴 식별 및 솔루션 재사용

- 테스트 파일에서 `@workspace` 에이전트로 pytest 포팅 방법을 질문하세요.

- 함수 기반 테스트를 우선 작성하세요.문제에서 공통 패턴을 인식하고, 적용 가능한 경우 솔루션을 재사용하세요. 레거시 Python 프로젝트에서 흔한 예는 Python 2.5의 예외 처리 방식이 Python 3+에서는 `SyntaxError`를 발생시키는 경우입니다.

- 하나의 테스트를 작성한 후 Copilot에게 다음 테스트 생성을 요청하세요.

레거시 프로젝트에서는 두 버전 모두를 처리하는 함수를 만들거나, Python 버전에 따라 모듈을 임포트하는 경우가 많습니다. 이는 다른 프로젝트에도 재사용할 수 있는 일반적인 패턴입니다.

> [!NOTE]

> `pytest`는 `unittest` 테스트도 실행할 수 있지만, 더 강력하고 유연하므로 포팅이 권장됩니다. 향후 테스트 추가/수정에도 도움이 됩니다.> [!TIP]

> 패턴 인식은 경험의 증거입니다. 유사한 문제를 반복적으로 접하다 보면, 유사점을 파악해 더 빠르게 해결할 수 있습니다.

### 9. 최신 패키징 적용

### 7. 제약 조건과 엣지 케이스로 견고성 확보

레거시 코드는 `distribute`와 `setup.py`를 사용합니다. 최신 표준인 `pyproject.toml`로 패키징하세요.

- Copilot에게 `pyproject.toml` 작성 방법을 질문하세요. `setup.py` 파일을 맥락에 추가하세요.엣지 케이스와 예외 상황을 고려하세요. 복잡한 문제는 "이상적" 데이터뿐 아니라 "엣지"나 "이례적" 데이터도 처리해야 합니다. 프롬프트나 솔루션에 이러한 엣지 케이스를 반영하세요.

- 새 `pyproject.toml` 파일을 만들고 Copilot 제안으로 내용을 채우세요.

- `pip install .`로 프로젝트를 설치하세요.레거시 코드에서는 예기치 않은 입력에 대한 동작을 고려해 새로운 테스트를 작성하거나 기존 테스트를 수정할 수 있습니다.



> [!NOTE]> [!TIP]

> Python 패키징은 여전히 어려운 주제입니다. Copilot의 제안이 항상 정확하지 않을 수 있으니, 파일 내용을 검증하고 설치를 테스트하세요.> 엣지 케이스를 고려하면 더 견고하고 일반화된 솔루션을 만들 수 있습니다. 테스트와 검증에 항상 중점을 두세요.



### 10. GitHub Actions로 자동화### 8. 도구의 효과적 활용



레거시 프로젝트에는 자동화가 없습니다. GitHub Actions로 테스트 및 검증을 자동화하세요. 모든 PR에서 테스트와 설치가 자동으로 실행되도록 워크플로우를 만드세요.GitHub Copilot, 에디터 자동완성, 기타 자동화 도구 등 사용 가능한 도구를 적극 활용하되, 올바른 맥락으로 안내하세요. 도구는 생성 속도를 높여주지만, 구조화된 입력과 직접적인 검증이 필요합니다.

- `@workspace` 에이전트로 GitHub Actions 워크플로우 작성 방법을 질문하세요.

- 필요한 파일과 디렉터리를 생성하세요.GitHub Copilot의 경우 프롬프트는 구체적이면서도 간결하게 작성하세요. 도구는 명확한 입력을 받을 때 가장 잘 작동합니다.

- 변경 사항을 푸시해 GitHub Actions가 동작하는지 확인하세요.

> [!TIP]

> [!NOTE]> 도구를 구체적으로 활용하되, 결과를 반드시 확인하세요. 도구가 맥락을 완전히 이해하지 못할 수 있습니다.

> 자동화 구축은 현대 소프트웨어 개발의 핵심입니다. Copilot을 활용해 오류와 이슈를 해결하며 인내심을 갖고 진행하세요.

### 9. 테스트 및 검증

테스트와 검증은 솔루션이 기대대로 동작하는지 확인하는 핵심 단계입니다. 레거시 코드의 경우, 새로운 코드가 기존 코드와 동일하게(혹은 더 잘) 동작하는지 반드시 확인해야 합니다.

테스트는 예상 상황과 예상치 못한 상황 모두를 올바르게 처리하는지 확인합니다.

> [!TIP]
> 실수를 조기에 발견할 수 있도록 검증 단계를 반드시 포함하세요.

기타 활용 사례 일반화:
코드나 알고리즘 작성: 입력, 기대 출력, 엣지 케이스를 명확히 정의하고 반복적으로 개선하세요.

AI 모델 프롬프트: 복잡한 요청(코드, 텍스트, 디자인 등) 시 명확한 목표, 문제 분해, 맥락 제공, 반복 개선을 적용하세요.

디자인/콘텐츠 생성: 목적 정의, 디자인 요소 분해, 예시나 영감 제공 후 피드백 기반 개선

최종 정리:
복잡한 생성 문제는 명확성, 분해, 반복, 검증의 균형이 중요합니다. SQL 쿼리든 다른 작업이든, 이 개념을 염두에 두면 더 정확하고 효율적이며 신뢰할 수 있는 결과를 얻을 수 있습니다.


## :books: 참고 자료

필수는 아니지만, 이 워크숍에서 다루는 일부 기능은 다음 Microsoft Learning 모듈에 포함되어 있습니다:

- [GitHub Codespaces로 코드 작성](https://learn.microsoft.com/training/modules/code-with-github-codespaces/)
- [고급 GitHub Copilot 기능 활용](https://learn.microsoft.com/training/modules/advanced-github-copilot/)

## 기여 안내

이 프로젝트는 기여와 제안을 환영합니다. 대부분의 기여는 Contributor License Agreement(CLA)에 동의해야 하며, 본인이 기여할 권리가 있고 실제로 기여함을 선언해야 합니다. 자세한 내용은 https://cla.opensource.microsoft.com 을 참조하세요.

풀 리퀘스트를 제출하면 CLA 봇이 자동으로 CLA 필요 여부를 판단하고 PR에 상태 체크나 코멘트를 추가합니다. 봇의 안내를 따라주세요. 한 번만 동의하면 모든 Microsoft CLA 저장소에 적용됩니다.

이 프로젝트는 [Microsoft 오픈소스 행동 강령](https://opensource.microsoft.com/codeofconduct/)을 채택했습니다.
자세한 내용은 [행동 강령 FAQ](https://opensource.microsoft.com/codeofconduct/faq) 또는 [opencode@microsoft.com](mailto:opencode@microsoft.com)으로 문의하세요.

## 상표 안내

이 프로젝트에는 Microsoft 프로젝트, 제품, 서비스의 상표 또는 로고가 포함될 수 있습니다. Microsoft 상표 또는 로고의 공식 사용은 반드시 [Microsoft 상표 및 브랜드 가이드라인](https://www.microsoft.com/en-us/legal/intellectualproperty/trademarks/usage/general)을 따라야 합니다.
프로젝트의 수정 버전에서 Microsoft 상표 또는 로고를 사용할 경우 혼동을 일으키거나 Microsoft의 후원을 암시해서는 안 됩니다.
타사 상표 또는 로고 사용은 해당 타사의 정책을 따라야 합니다.
